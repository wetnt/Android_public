package bbk.map.lay;

import bbk.bbk.box.BBKSoft;
import bbk.map.lay.BBKMapLay.Lay_type;
import bbk.map.lay.BBKMapLay.line_type;
import bbk.map.lay.BBKMapLay.poi_type;
import bbk.zzz.debug.bd;

public class BBKMapEdit {

	public static int rxy = 20;

	// http://help.eclipse.org/helios/index.jsp?topic=%2Forg.eclipse.platform.doc.isv%2Freference%2Fapi%2Forg%2Feclipse%2Fswt%2FSWT.html
	// ====================================================================================
	public static boolean MouseTouchLay(Lay_type lay, int x, int y) {
		// ----------------------------------------------------------------------------
		if (LayTouch(lay, x, y, rxy)) {
			return true;
		} else {
			return false;
		}
		// -------------------------------------------------------------------------------------
	}

	// ------------------------------------------------------------
	private static boolean LayTouch(Lay_type lay, int x, int y, int r) {
		// ------------------------------------------------------------
		BBKSoft.myLays.laytmp = new Lay_type();
		// ------------------------------------------------------------
		boolean yes = false;
		layeClear();
		// ------------------------------------------------------------
		for (int i = 0; i < lay.pois.size(); i++) {
			if (PoisTouch(lay.pois.get(i), x, y, r)) {
				BBKSoft.myLays.laytmp.pois.add(lay.pois.get(i));
				layEpAdd(i);
				yes = true;
			}
		}
		// ------------------------------------------------------------
		for (int i = 0; i < lay.line.size(); i++) {
			int z = LineTouch(lay.line.get(i), x, y, r);
			if (z != -1) {
				layElAdd(i, z);
				BBKSoft.myLays.laytmp.line.add(lay.line.get(i));
				yes = true;
			}
		}
		// ------------------------------------------------------------
		for (int i = 0; i < lay.poly.size(); i++) {
			int z = LineTouch(lay.poly.get(i), x, y, r);
			if (z != -1) {
				BBKSoft.myLays.laytmp.poly.add(lay.poly.get(i));
				layEyAdd(i, z);
				yes = true;
			}
		}
		// ------------------------------------------------------------
		if (yes)
			layDebug();
		// ------------------------------------------------------------
		return yes;
		// ------------------------------------------------------------
	}

	// =================================================================================

	// =================================================================================
	private static boolean PoisTouch(poi_type poi, int x, int y, int r) {
		// -----------------------------------------------------------------------------
		if (poi == null || !poi.p.v)
			return false;
		// -----------------------------------------------------------------------------
		return PointXYNeed(poi.p.x, poi.p.y, x, y);
		// -----------------------------------------------------------------------------
	}

	private static int LineTouch(line_type line, int x, int y, int r) {
		// -----------------------------------------------------------------------------
		if (line == null || !line.pv)
			return -1;
		// -----------------------------------------------------------------------------
		for (int i = 0; i < line.p.size(); i++) {
			// -------------------------------------------------------------------------
			if (PointXYNeed(line.p.get(i).x, line.p.get(i).y, x, y))
				return i;
			// -------------------------------------------------------------------------
		}
		// -----------------------------------------------------------------------------
		for (int i = 1; i < line.p.size(); i++) {
			// -------------------------------------------------------------------------
			// BBKDebug.ddd(i + "----");
			if (TriangleLPNeed(line.p.get(i - 1).x, line.p.get(i - 1).y, line.p.get(i).x, line.p.get(i).y, x, y))
				return i;
			// -------------------------------------------------------------------------
		}
		// -----------------------------------------------------------------------------
		return -1;
		// -----------------------------------------------------------------------------
	}

	// =================================================================================
	private static boolean PointXYNeed(int ax, int ay, int px, int py) {
		// -----------------------------------------------------------------------------
		if (Math.abs(ax - px) < rxy && Math.abs(ay - py) < rxy) {
			// BBKDebug.ddd(" = " + ax + " = " + px + " = " + ay + " = " + py);
			return true;
		}
		// -----------------------------------------------------------------------------
		return false;
		// -----------------------------------------------------------------------------
	}

	// =================================================================================
	private static boolean TriangleLPNeed(int ax, int ay, int bx, int by, int px, int py) {
		// -----------------------------------------------------------------------------
		double r = GetNearestDistance(ax, ay, bx, by, px, py, rxy);
		if (r < rxy) {
			// BBKDebug.ddd(r + "====rxy" + " = " + px + "_" + py + " " + ax +
			// "_" +
			// ay + " " + bx + "_" + by);
			return true;
		}
		// -----------------------------------------------------------------------------
		return false;
		// -----------------------------------------------------------------------------
	}

	// =================================================================================
	// =================================================================================

	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================

	// ====================================================================================
	public static int layes = 20;
	public static int[] laypi = new int[layes];
	public static int[] layli = new int[layes];
	public static int[] laylp = new int[layes];
	public static int[] layyi = new int[layes];
	public static int[] layyp = new int[layes];

	public static void layeClear() {
		// ----------------------------------------
		for (int i = 0; i < layes; i++) {
			laypi[i] = -1;
			layli[i] = -1;
			laylp[i] = -1;
			layyi[i] = -1;
			layyp[i] = -1;
		}
		// ----------------------------------------
	}

	public static void layEpAdd(int n) {
		// ----------------------------------------
		for (int i = 0; i < layes; i++) {
			if (laypi[i] == -1) {
				laypi[i] = n;
				return;
			}
		}
		// ----------------------------------------
	}

	public static void layElAdd(int n, int p) {
		// ----------------------------------------
		for (int i = 0; i < layes; i++) {
			if (layli[i] == -1) {
				layli[i] = n;
				laylp[i] = p;
				return;
			}
		}
		// ----------------------------------------
	}

	public static void layEyAdd(int n, int p) {
		// ----------------------------------------
		for (int i = 0; i < layes; i++) {
			if (layyi[i] == -1) {
				layyi[i] = n;
				layyp[i] = p;
				return;
			}
		}
		// ----------------------------------------
	}

	public static void layDebug() {
		// ----------------------------------------
		bd.d("----------layDebug---------------", false, false);
		// ----------------------------------------
		for (int i = 0; i < layes; i++) {
			if (laypi[i] != -1 || layli[i] != -1 || layyi[i] != -1) {
				bd.d(laypi[i] + " " + layli[i] + " " + laylp[i] + " " + layyi[i] + " " + layyp[i], false, false);
			}
		}
		// ----------------------------------------
	}

	public static String layGetString() {
		// --------------------------------------------
		String str = "";
		// --------------------------------------------
		for (int i = 0; i < layes; i++) {
			if (layli[i] != -1) {

				str += layli[i] + ",";
			}
		}
		// --------------------------------------------
		return str;
		// --------------------------------------------
	}

	public static int layGetEditN() {
		// --------------------------------------------
		int n = 0;
		// --------------------------------------------
		if (laypi[n] != -1) {
			return laypi[n];
		} else if (layli[n] != -1) {
			return layli[n];
		} else if (layyi[n] != -1) {
			return layyi[n];
		} else {
			return -1;
		}
		// --------------------------------------------
	}

	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================
	// ====================================================================================

	// =================================================================================
	// 一种快速求点到线段距离的算法
	// http://blog.163.com/maosth@126/blog/static/135068435201002111739759/
	// =================================================================================
	private static double GetPointDistance(int ax, int ay, int px, int py) {
		return Math.sqrt((ax - px) * (ax - px) + (ay - py) * (ay - py));
	}

	private static double GetNearestDistance(int ax, int ay, int bx, int by, int px, int py, int rs) {
		// ----------图2--------------------
		double a, b, c;
		a = GetPointDistance(bx, by, px, py);
		if (a <= rs)
			return a;
		b = GetPointDistance(ax, ay, px, py);
		if (b <= rs)
			return b;
		c = GetPointDistance(ax, ay, bx, by);
		if (c <= 1)
			return Math.min(a, b);// 如果PA和PB坐标相同，则退出函数，并返回距离
		// ------------------------------
		if (a * a >= b * b + c * c)
			return b;
		if (b * b >= a * a + c * c)
			return a;
		double l = (a + b + c) / 2; // 周长的一半
		double s = Math.sqrt(l * (l - a) * (l - b) * (l - c)); // 海伦公式求面积
		return 2 * s / c;
		// ------------------------------
	}
	// =================================================================================
}
